Быстрый диагностический код (вставь прямо сейчас)

Вставь эту функцию в проект и используй её вместо текущего извлечения response.text. Она:

Попытается извлечь текст из разных форматов ответов (атрибуты, dict-поля, вложенные структуры).

Залогирует (в файл response_debug.json) безопасную структурированную версию ответа для анализа (без токенов).

Вернёт разумный fallback.

import json, logging, os
logger = logging.getLogger(__name__)

DEBUG_DUMP = os.getenv("DEBUG_RESPONSE_DUMP", "response_debug.json")

def _safe_to_primitive(obj):
    """Попытка сериализовать объект в JSON-совместимую структуру (без токенов)."""
    try:
        # если это dict-like
        if isinstance(obj, dict):
            return {k: _safe_to_primitive(v) for k, v in obj.items()}
        # списки/кортежи
        if isinstance(obj, (list, tuple)):
            return [_safe_to_primitive(x) for x in obj]
        # объект с to_dict()
        if hasattr(obj, "to_dict"):
            return _safe_to_primitive(obj.to_dict())
        # простые типы
        if isinstance(obj, (str, int, float, bool)) or obj is None:
            return obj
        # объект с __dict__
        if hasattr(obj, "__dict__"):
            return _safe_to_primitive(obj.__dict__)
        # fallback to str()
        return str(obj)
    except Exception as e:
        return f"<unserializable: {e}>"

def extract_text_from_response(response):
    """
    Универсальный парсер ответа. Возвращает строку с текстом ответа и сохраняет debug-dump.
    """
    # 1. Сначала логируем структурированный дамп (без секретов)
    try:
        dump = _safe_to_primitive(response)
        with open(DEBUG_DUMP, "a", encoding="utf-8") as f:
            f.write(json.dumps({"ts": __import__("time").time(), "dump": dump}, ensure_ascii=False) + "\n")
    except Exception as e:
        logger.exception("Не удалось сохранить debug dump: %s", e)

    # 2. Попытки извлечения текста — несколько стратегий
    candidates = []

    # if object has .text
    try:
        txt = getattr(response, "text", None)
        if txt:
            candidates.append(txt)
    except Exception:
        pass

    # common dict keys
    try:
        if isinstance(response, dict):
            keys = ["text", "output", "outputs", "candidates", "message", "result", "content"]
            for k in keys:
                if k in response and response[k]:
                    candidates.append(response[k])
    except Exception:
        pass

    # try to_dict / to_message / choices
    try:
        # .to_dict() -> parse recursively
        if hasattr(response, "to_dict"):
            d = response.to_dict()
            # search for strings inside dict deeply
            def walk(o):
                if isinstance(o, str):
                    return [o]
                if isinstance(o, dict):
                    res = []
                    for v in o.values():
                        res += walk(v)
                    return res
                if isinstance(o, list):
                    res = []
                    for i in o:
                        res += walk(i)
                    return res
                return []
            candidates += walk(d)
    except Exception:
        pass

    # fallback: convert to str
    try:
        candidates.append(str(response))
    except Exception:
        pass

    # Flatten candidates and pick the longest non-empty string (heuristic)
    flat = []
    def flatten(x):
        if x is None:
            return
        if isinstance(x, str):
            flat.append(x.strip())
            return
        if isinstance(x, (list, tuple)):
            for i in x:
                flatten(i)
            return
        if isinstance(x, dict):
            for v in x.values():
                flatten(v)
            return
        # other types -> str
        flat.append(str(x).strip())

    for c in candidates:
        flatten(c)

    # choose best candidate: first non-empty with some length, otherwise first non-empty
    best = ""
    for s in flat:
        if len(s) > len(best):
            best = s

    best = best or "Что-то я сегодня молчун... ну ты понял."
    # ограничим длину
    if len(best) > 4000:
        best = best[:4000] + " ...[обрезано]"

    return best